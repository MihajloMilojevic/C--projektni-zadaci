Направите апликацију (веб или десктоп) са графичким интерфејсом који ће омогућити рад са блоцкцхаином.
Имплементирајте валидацију блокова и читавог ланца , као и стварање нових блокова (рударење).
Имплементирајте рударење нових блокова помоћу консензусног алгоритма „proof-of-work“ .
Поред тога, имплементирајте променљиву тежину генерисања нових блокова на мрежи, проверу временске ознаке и кумулативну тежину.
Комуникација између више инстанци ваше апликације мора да се одвија преко мреже! 
У супротном, задатак ће бити оцењен са 0 бодова!

Блок структура
Сваки блок треба да има следеће елементе:

индекс
подаци (data)
временска ознака (timestamp)
хеширана вредност блока (hash)
хеш вредност претходног блока (previousHash)
Када креирате први блок у ланцу, обратите пажњу на хеш вредност претходног блока , која треба да буде једнака 0 .


алидација блокова и ланаца
Када се нови блокови додају у ланац, они морају бити валидирани или проверите њихов интегритет . Морају бити испуњени следећи услови:

индекс тренутног блока је за 1 већи од претходног блока
хеширане вредности морају бити одговарајуће
currentBlock.previousHash == previousBlock.hash
calculateHash(currentBlock) == currentBlock.hash
Израчунајте хеш вредност блока из елемената блока . Користите SHA-256 хеш функцију .

hash = sha256(index + timestamp + data + previousHash)
Интегритет целог ланца проверавамо провером интегритета свих блокова који се налазе у ланцу.
Ако установите да се блок или ланац не могу потврдити, напишите то или цртати у графичком интерфејсу апликације . 
Због паралелности , можете завршити са различитим стањима ланца на појединачним чворовима. У овом случају се примењује дужи ланац .



Рударење и алгоритам за проверу рада
Ако можемо да потврдимо блок, можемо га додати у блоцкцхаин пошто испуњава услове за интегритет.
Ово није увек пожељно , пошто у дистрибуираном систему свако може да додаје нове блокове у ланац. 
Пошто желимо да ово ограничимо, уводимо рачунски проблем који се мора решити пре него што се нови блок може додати у ланац. 
Процес решавања овог рачунарског проблема назива се рударење .

Када имплементирате рударење , проширите структуру блока помоћу токена за једнократну употребу (nonce) и вредности тежине. 
Вредност тежине ће бити број нула које хеш вредност блока мора да има на почетку да би блок био валидан.

diff=5 => 000007e13d3a75526946a3bcf00daec9fc9c9c4d51ddc7cc5df888f74dd434d1
diff=11 => 00000000000f58d61cf048d168aa6f5e492dea166d8bb54ec06c30de07db57e1


Токен за једнократну употребу (nonce) и вредност тежине се користе приликом израчунавања хеш вредности.
hash = sha256(index + timestamp + data + previousHash + diff + nonce)

Примените алгоритам рударења (proof-of-work) са једноставним алгоритмом (brute-force) који ће израчунати одговарајуће хеш вредности док мењате токен за једнократну употребу.

nonce = 0
while(true)
  hash = sha256(index + timestamp + data + previousHash + diff + nonce)
  if( hash ustreza diff ) then 
     return new Block(index, timestamp, data, hash, previousHash, diff, nonce)
  else
     nonce++
end while

Тренутна потешкоћа са мрежом
Сви чворови у мрежи морају се сложити око тежине, тако да је неопходно дефинисати правила за одређивање тренутне тежине у мрежи . 
У ту сврху додајте интервал генерисања блока и константе интервала корекције потешкоћа . 
Интервал генерисања блока говори у које време се нови блок може пронаћи. 
Користите јединицу времена за вредност (нпр. 10 секунди - сваких 10 секунди можемо убацити нови блок у ланац). 
Интервал прилагођавања тежине говори колико често ће се тежина мењати. 
Користите број блокова за вредност (нпр. 10 блокова - након 10 додатих блокова тежина ће се променити). 
Производ ове две константе нам говори очекивано време генерисања блока , које користимо у алгоритму за корекцију тежине. 
Повећавамо тежину за 1, ако генерација траје најмање 2 пута мање времена од очекиваног и смањимо за 1 , ако генерација траје најмање 2 пута дуже од очекиваног.

previousAdjustmentBlock = Blockchain[Blockchain.length - diffAdjustInterval]
timeExpected = blockGenerationInterval * diffAdjustInterval
timeTaken = latestBlock.timestamp - prevAdjustmentBlock.timestamp

if ( timeTaken < (timeExpected / 2) ) then
   return prevAdjustmentBlock.difficulty + 1 // повећање потешкоће
else if ( timeTaken > (timeExpected * 2) ) then
   return prevAdjustmentBlock.difficulty - 1 // смањење потешкоће
else
   return prevAdjustmentBlock.difficulty //  остане једнака


Валидација временске ознаке и кумулативна потешкоћа
Временска ознака је важна информација, јер утиче на потешкоћу рударења када се тренутна потешкоћа уведе у мрежу .
 Зато нам је потребна валидација временске ознаке . Примените следећа два правила валидације :

блок је валидан ако је његова временска ознака за највише 1 минут већа од нашег тренутног времена
блок у ланцу је релевантан ако је његова временска ознака за највише 1 минут мања од временске ознаке претходног блока
Због увођења потешкоћа на нивоу мреже, морамо да променимо метод валидације целог ланца .
 У случају сукоба истовремености , најдужи ланац се више не примењује , већ ланац са највећом кумулативном тежином . 
Ово је ланац где је било потребно потрошити највише системских ресурса и времена. 
Израчунавање кумулативне тежине ланца је једноставно, јер за сваки блок у ланцу израчунавамо 2 на блока.потешкоће  и додајемо вредности.
